# persistent-storage


## Описание

За вашими плечами уже далеко не одна написанная структура данных. Однако, скорее всего, каждая из них существовала лишь до завершения работы программы. Так почему бы не написать такую структуру, которая сможет оставить след в истории? Или хотя бы на диске.

Key-Value хранилища предоставляют возможность записывать и получать данные по ключу, что напоминает интерфейс `std::map`. Как правило, во время работы хранилище располагается в оперативной памяти (для обеспечения быстрого доступа), но при этом сбрасывает изменения на диск, чтобы, например, не потерять данные при перезапуске машины. Также при таком подходе есть возможность хранить всю историю изменения значений ключей (иначе говоря, смотреть предыдущие версии).

## Задание

В файле `public/storage.h` можно найти саму структуру `Storage` и объявление связанных с ней фунций `storage_init`, `storage_destroy`, `storage_set`, `storage_get`, `storage_get_by_version`.


Предлагается реализация со следующими особенностями:

- Ключи и значения - С-строки размером не более `MAX_KEY_SIZE` и `MAX_VALUE_SIZE` соответственно
- Ключи соответствуют регулярному выражению `[a-zA-Z0-9_]{3,}`
- `storage_init` получает на вход путь к папке, которую можно использовать для хранения данных (из этой же папки хранилище будет восстанавливаться после перезапуска)
- `storage_set` возвращает новую версию ключа
- `storage_get` и `storage_get_by_version` не выделяют память под значения сами, в качестве аргумента приходит указатель на уже выделенную память
- Каждому ключу соответствует ровно один файл, все версии ключа хранятся в одном файле
- Хранить значения в памяти не обязательно, можно каждый раз доставать их с диска
- Путь, по которому будут лежать значения ключа, определяется следующим образом: ключ разбивается на блоки по `SUBDIR_NAME_SIZE` (в примерах равно двум); если длина ключа кратна размеру блока, то в качестве названия файла можно выбрать произвольный символ, не используемый в ключах
    - Примеры:
        - `key` -> `ke/y`
        - `longerkey` -> `lo/ng/er/ke/y`
        - `evenkeyy`-> `ev/en/ke/yy/@`

От вас требуется реализовать функции `storage_init`, `storage_destroy`, `storage_set`, `storage_get`, `storage_get_by_version`. Шаблон решения находится в файле `template/storage.c`.


## Тесты

Протестировать своё решение можно с помощью публичных тестов, описанных в `public/tester.c`. Они делятся на три набора:

- `unit` - проверяют работоспособность реализованных функций
- `persistence` - проверяют, переживает ли хранилище перезапуск программы
- `stress` - проверяют требуемую иерархию файлов путём создания большого количества пар ключ-значения


## Дополнительная информация todo

- [Статья на Википедии](https://en.wikipedia.org/wiki/Key–value_database)
- [Redis](https://redis.io) - пример in-memory KV-хранилища
- [ZooKeeper](https://zookeeper.apache.org) - сервис для координации распределённых систем, под капотом использует KV-хранилище
